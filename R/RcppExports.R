# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generalized linear model constraint on hierarchical structure
#' by using overlapped group penalty
#' 
#' @param y a vector of numeric value for response variable in the 
#'          generalized linear regression. A matrix of n by 2 for 
#'          survival objects. See \code{\link[survival]{Surv}}.
#' @param x the design matrix of n by p. 
#' @param g a vector of group labels for the p predictor variables.
#' @param v a vector of 0 and 1 for the penalization status of the 
#'          p predictor variables. 1 is for penalization and 0 for 
#'          not penalization. 
#' @param hierarchy hierarchy indicator. 0 for L2 penalty, 1 for the
#'                  composite L1 and L2 penalty, and 2 for the 
#'                  composite L1, L2 and ridge penalty for each 
#'                  group, respectively.  
#' @param type character variable, for different linear models based
#'             on the response variable. For continuous response variable,
#'             type is set ``lm''; for multinomial or binary response 
#'             variable, type is set ``binomial''; for survival response 
#'             variable, type is set ``survival'', respectively. 
#' @param lambda penalty parameters, should correspond to the hierarchy
#'               status. 
#' @param rho   The penalty parameter in the ADMM algorithm. Default is 1e-3.
#' @param scale Whether or not scale the design matrix. Default is true.
#' @param eabs  The absolute tolerance in the ADMM algorithm. Default is 1e-3.
#' @param erel  The reletive tolerance in the ADMM algorithm. Default is 1e-3. 
#' @param LL    Initial value for the coefficient of the second-order term in 
#'              the Majorization-Minimization step. 
#' @param eta   gradient step in the FISTA algorithm.
#' @param maxitr The maximum iterations in the ADMM algorithm. Default is 500. 
#'
#' @examples 
#' 
#' require(coxed)
#' n=50;p=1000
#' set.seed(2018)
#' # set design matrix
#' s=10
#' x=matrix(0,n,1+2*p)
#' x[,1]=sample(c(0,1),n,replace = TRUE)
#' x[,seq(2,1+2*p,2)]=matrix(rnorm(n*p),n,p)
#' x[,seq(3,1+2*p,2)]=x[,seq(2,1+2*p,2)]*x[,1]
#' 
#' # set beta 
#' beta=c(rnorm(13,0,2),rep(0,ncol(x)-13))
#' beta[c(2,4,7,9)]=0
#' 
#' # set y
#' data1=x%*%beta
#' noise1=rnorm(n)
#' snr1=as.numeric(sqrt(var(data1)/(s*var(noise1))))
#' y1=data1+snr1*noise1
#' g=c(p+1,rep(1:p,rep(2,p)))
#' v=c(0,rep(1,2*p))
#' \dontrun{
#' lfit1=glog(y=as.matrix(y1),x=as.matrix(x),g=g,v=v,
#'           hierarchy=1,lambda=c(0.01,0.001))
#' }
#' 
#' ## binomial data 
#' prob=exp(as.matrix(x)%*%as.matrix(beta))/(1+exp(as.matrix(x)%*%as.matrix(beta)))
#' y2=ifelse(prob<0.5,0,1)
#' \dontrun{
#' lfit2=glog(y=as.matrix(y2),x=as.matrix(x),g=g,v=v,
#'            hierarchy=1,lambda=c(0.025,0.001))
#' }
#' 
#' ## survival data 
#' data3=sim.survdata(N=n,T=100,X=x,beta=beta)
#' y3=data3$data[,c("y","failed")]
#' y3$failed=ifelse(y3$failed,1,0)
#' 
#' \dontrun{
#' lfit3=glog(y=as.matrix(y3),x=as.matrix(x),g=g,v=v,
#'            hierarchy=1,lambda=c(0.075,0.001),
#'            type="survival")
#' }
#'
glog <- function(y, x, g, v, hierarchy, lambda, type = "lm", rho = 1e-3, scale = TRUE, eabs = 1e-3, erel = 1e-3, LL = 100, eta = 1.25, maxitr = 500L) {
    .Call('_smog_glog', PACKAGE = 'smog', y, x, g, v, hierarchy, lambda, type, rho, scale, eabs, erel, LL, eta, maxitr)
}

#' Integrative generalized linear model constraint on hierarchical structure
#' by using overlapped group penalty 
#' 
#' @param y1 a survival object contains the survival time and censoring status 
#'           from data1. See \code{\link[survival]{Surv}}.
#' @param x1 the design matrix of n by p from data1. 
#' @param y2 a survival object contains the survival time and censoring status 
#'           from data2. See \code{\link[survival]{Surv}}.
#' @param x2 the design matrix of n by p from data2. x1 and x2 should have 
#'           the same number of columns. 
#' @param g a vector of group labels for the p predictor variables.
#' @param v a vector of 0 and 1 for the penalization status of the 
#'          p predictor variables. 1 is for penalization and 0 for 
#'          not penalization. 
#' @param hierarchy hierarchy indicator. 0 for L2 penalty, 1 for the
#'                  composite L2 penalty, and 2 for the composite L2 
#'                  and ridge penalty for each group, respectively.  
#' @param type character variable, for different linear models based
#'             on the response variable. For continuous response variable,
#'             type is set ``lm''; for multinomial or binary response 
#'             variable, type is set ``binomial''; for survival response 
#'             variable, type is set ``survival'', respectively. 
#' @param lambda penalty parameters, should correspond to the hierarchy
#'               status. 
#' @param rho   The penalty parameter in the ADMM algorithm. Default is 1e-3.
#' @param scale Whether or not scale the design matrix. Default is true.
#' @param eabs  The absolute tolerance in the ADMM algorithm. Default is 1e-3.
#' @param erel  The reletive tolerance in the ADMM algorithm. Default is 1e-3. 
#' @param LL    Initial value for the coefficient of the second-order term in 
#'              the Majorization-Minimization step. 
#' @param eta   gradient step in the FISTA algorithm.
#' @param maxitr The maximum iterations in the ADMM algorithm. Default is 500. 
#'
#' @examples 
#' 
#' require(coxed)
#' n=50;p=1000
#' set.seed(2018)
#' # generate two design matrices x1 and x2
#' s=10
#' x1=matrix(0,n,1+2*p)
#' x1[,1]=sample(c(0,1),n,replace = TRUE)
#' x1[,seq(2,1+2*p,2)]=matrix(rnorm(n*p),n,p)
#' x1[,seq(3,1+2*p,2)]=x1[,seq(2,1+2*p,2)]*x1[,1]
#' 
#' x2=matrix(0,n,1+2*p)
#' x2[,1]=x1[,1]
#' x2[,seq(2,1+2*p,2)]=matrix(rnorm(n*p),n,p)
#' x2[,seq(3,1+2*p,2)]=x2[,seq(2,1+2*p,2)]*x2[,1] 
#' 
#' # generate beta1 and beta2 
#' beta1=beta2=c(rnorm(13,0,2),rep(0,ncol(x1)-13))
#' beta2[1:13]=beta2[1:13]+rnorm(13,0,0.1)
#' beta1[c(2,4,7,9)]=beta2[c(2,4,7,9)]=0
#' 
#' # generate two continuous y1 and y2
#' ldata1=x1%*%beta1
#' noise1=rnorm(n)
#' snr1=as.numeric(sqrt(var(ldata1)/(s*var(noise1))))
#' ly1=ldata1+snr1*noise1
#' 
#' ldata2=x2%*%beta2
#' noise2=rnorm(n)
#' snr2=as.numeric(sqrt(var(ldata2)/(s*var(noise1))))
#' ly2=ldata2+snr2*noise2 
#' 
#' g=c(p+1,rep(1:p,rep(2,p)))
#' v=c(0,rep(1,2*p))
#' \dontrun{
#' ilfit1=iglog(y1=as.matrix(ly1),x1=as.matrix(x1),
#'              y2=as.matrix(ly2),x2=as.matrix(x2),
#'              g=g,v=v,hierarchy=1,lambda=c(0.01,0.001),
#'              type="lm")
#' }
#' 
#' ## generate two binomial data 
#' prob1=exp(as.matrix(x1)%*%as.matrix(beta1))/(1+exp(as.matrix(x1)%*%as.matrix(beta1)))
#' cy1=ifelse(prob1<0.5,0,1)
#' 
#' prob2=exp(as.matrix(x2)%*%as.matrix(beta2))/(1+exp(as.matrix(x2)%*%as.matrix(beta2)))
#' cy2=ifelse(prob2<0.5,0,1)
#' 
#' \dontrun{
#' ilfit2=iglog(y1=as.matrix(cy1),x1=as.matrix(x1),
#'              y2=as.matrix(cy2),x2=as.matrix(x2),
#'              g=g,v=v,hierarchy=1,lambda=c(0.025,0.001),
#'              type="binomial")
#' }
#' 
#' ## generate two survival data 
#' sdata1=sim.survdata(N=n,T=100,X=x1,beta=beta1)
#' sy1=sdata1$data[,c("y","failed")]
#' sy1$failed=ifelse(sy1$failed,1,0)
#' 
#' sdata2=sim.survdata(N=n,T=100,X=x2,beta=beta2)
#' sy2=sdata2$data[,c("y","failed")]
#' sy2$failed=ifelse(sy2$failed,1,0)
#' 
#' \dontrun{
#' ilfit3=iglog(y1=as.matrix(sy1),x1=as.matrix(x1),
#'              y2=as.matrix(sy2),x2=as.matrix(x2),
#'              g=g,v=v,hierarchy=1,lambda=c(0.075,0.001),
#'              type="survival")
#' }
#'
iglog <- function(y1, x1, y2, x2, g, v, hierarchy, lambda, type = "lm", rho = 1e-3, scale = TRUE, eabs = 1e-3, erel = 1e-3, LL = 100, eta = 1.25, maxitr = 500L) {
    .Call('_smog_iglog', PACKAGE = 'smog', y1, x1, y2, x2, g, v, hierarchy, lambda, type, rho, scale, eabs, erel, LL, eta, maxitr)
}

#' proximal operator on L1 penalty
#' @param x numeric value.
#' @param lambda numeric value for the L1 penalty parameter.
#'  
proxL1 <- function(x, lambda) {
    .Call('_smog_proxL1', PACKAGE = 'smog', x, lambda)
}

#' proximal operator on L2 penalty
#' @param x A numeric vector.
#' @param lambda numeric value for the L2 penalty parameter.
#'  
proxL2 <- function(x, lambda) {
    .Call('_smog_proxL2', PACKAGE = 'smog', x, lambda)
}

#' proximal operator on the composite L1, L2, and ridge penalty
#' @param x A numeric vector of two.
#' @param lambda a vector of three penalty parameters. \eqn{\lambda[1]}
#'        is the L2 penalty for x, \eqn{\lambda[2]} is the ridge penalty
#'        for x, and \eqn{\lambda[3]} is the ridge penalty for x[2], respectively.
#' @param hierarchy Indicator variable for 0, 1, 2. 0 is for no overlap, 1 for 
#'        composite L1 and L2 penalty, and 2 for composite L1, L2 and ridge 
#'        penalty, respectively.
#' @param d indices for overlapped variables in x.   
#' 
prox <- function(x, lambda, hierarchy, d) {
    .Call('_smog_prox', PACKAGE = 'smog', x, lambda, hierarchy, d)
}

#' Penalty function on the composite L1, L2, and ridge penalty
#' @param x A numeric vector of two.
#' @param lambda a vector of three penalty parameters. \eqn{\lambda[1]}
#'        is the L2 penalty for x, \eqn{\lambda[2]} is the ridge penalty
#'        for x, and \eqn{\lambda[3]} is the L1 penalty for x[2], respectively.
#' @param hierarchy Indicator variable for 0, 1, 2. 0 is for no overlap, 1 for 
#'        composite L1 and L2 penalty, and 2 for composite L1, L2 and ridge 
#'        penalty, respectively.  
#' @param d indices for overlapped variables in x. 
#' 
penalty <- function(x, lambda, hierarchy, d) {
    .Call('_smog_penalty', PACKAGE = 'smog', x, lambda, hierarchy, d)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_smog_RcppExport_registerCCallable', PACKAGE = 'smog')
})
